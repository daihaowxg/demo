好的，我们来详细讲解一下快速排序（Quick Sort）。快速排序是另一种非常高效且广泛使用的排序算法，它也是基于**分治思想（Divide and Conquer）**。与归并排序不同的是，快速排序通过**选择一个“基准”（pivot）元素**，然后将数组划分为两个子数组：一个子数组中的所有元素都小于或等于基准，另一个子数组中的所有元素都大于或等于基准。然后，再递归地对这两个子数组进行快速排序。

**快速排序的基本步骤可以概括为以下三步：**

1.  **选择基准（Pivot）：** 从数组中选择一个元素作为基准（pivot）。选择基准的方式有很多种，常见的有选择第一个元素、最后一个元素、中间元素或者随机选择一个元素。基准的选择会影响算法的性能，但好的选择可以使其平均性能达到最优。

2.  **分区（Partition）：** 重新排列数组，使得所有小于或等于基准的元素都移动到基准的左边，所有大于或等于基准的元素都移动到基准的右边。在分区结束后，基准元素就位于其最终排序后的正确位置上。这个操作会返回基准元素最终所在的索引位置。

3.  **递归排序（Recursion）：** 递归地对基准左边的子数组和右边的子数组进行快速排序。递归的终止条件是子数组的大小为 0 或 1，因为长度为 0 或 1 的数组已经是排好序的。

**让我们通过一个例子来理解这个过程：**

假设我们要排序的数组是 `[7, 2, 1, 6, 8, 5, 3, 4]`

**1. 选择基准（Pivot）：**

我们选择最后一个元素 `4` 作为基准（这是一种常见的选择）。

**2. 分区（Partition）：**

我们需要遍历数组（除了基准元素），将小于或等于基准的元素放到左边，大于或等于基准的元素放到右边。

初始状态：`[7, 2, 1, 6, 8, 5, 3, 4]`，基准是 `4`

* 从左边开始，`7 > 4`，所以 `7` 应该在基准的右边。
* `2 <= 4`，`2` 保持在原位。
* `1 <= 4`，`1` 保持在原位。
* `6 > 4`，所以 `6` 应该在基准的右边。
* `8 > 4`，所以 `8` 应该在基准的右边。
* `5 > 4`，所以 `5` 应该在基准的右边。
* `3 <= 4`，所以 `3` 应该在基准的左边。

经过分区操作，一种可能的结果是（基准 `4` 会被放到它最终的位置）：

`[3, 2, 1, 4, 8, 5, 6, 7]`

在这个过程中，基准 `4` 左边的元素都小于等于它，右边的元素都大于等于它。`4` 现在处于其最终排序后的位置。

**3. 递归排序（Recursion）：**

现在，我们需要递归地对基准 `4` 左边的子数组 `[3, 2, 1]` 和右边的子数组 `[8, 5, 6, 7]` 进行快速排序。

* **对 `[3, 2, 1]` 进行快速排序：**
    * 选择基准（例如最后一个元素 `1`）。
    * 分区，得到 `[1, 2, 3]`。
    * 递归排序 `[1]`（已排序）和 `[3]`（已排序）。

* **对 `[8, 5, 6, 7]` 进行快速排序：**
    * 选择基准（例如最后一个元素 `7`）。
    * 分区，得到 `[5, 6, 7, 8]`。
    * 递归排序 `[5, 6]` 和 `[8]`（已排序）。
        * 对 `[5, 6]` 进行快速排序（选择 `6` 为基准），得到 `[5, 6]`。

最终，经过所有的递归调用，整个数组都会被排序为 `[1, 2, 3, 4, 5, 6, 7, 8]`。

**分区（Partition）操作的详细步骤（以选择最后一个元素作为基准为例）：**

1.  选择数组的最后一个元素作为基准（pivot）。
2.  维护一个指向小于基准的元素的最后一个位置的索引 `i`（初始值为 `left - 1`）。
3.  遍历数组，从 `left` 到 `right - 1` 的每个元素 `arr[j]`：
    * 如果 `arr[j]` 小于或等于基准，则将 `i` 加 1，并交换 `arr[i]` 和 `arr[j]`。这样做的目的是将小于基准的元素移动到子数组的左边。
4.  遍历结束后，将基准元素（`arr[right]`) 与 `arr[i + 1]` 进行交换。这样做的目的是将基准元素放到它最终排序后的正确位置上，即所有小于它的元素都在它的左边，所有大于它的元素都在它的右边。
5.  返回基准元素最终所在的索引 `i + 1`。

**快速排序的特点和性质：**

* **时间复杂度：**
    * **平均情况和最佳情况：O(n log n)**。这得益于每次分区操作都能有效地将数组分成两个大小接近的子数组。
    * **最坏情况：O(n^2)**。当每次分区都选择到最小或最大的元素作为基准时，会导致每次只能将数组的大小缩小 1，从而退化为类似冒泡排序的性能。这种情况在输入数组已经有序或基本有序时容易发生。
* **空间复杂度：**
    * **平均情况：O(log n)**。这主要是由于递归调用栈的深度。
    * **最坏情况：O(n)**。在最坏情况下，递归深度会达到 `n`。
* **不稳定性（Unstable）：** 快速排序通常是一种不稳定的排序算法。这意味着如果待排序序列中存在值相等的元素，在排序后它们的相对顺序可能会发生改变。
* **原地排序（In-place）：** 快速排序通常被实现为原地排序算法，这意味着它只需要很小的额外空间（主要用于递归调用栈），而不需要像归并排序那样需要额外的 O(n) 空间来合并子数组。
* **性能优势：** 在平均情况下，快速排序通常比其他 O(n log n) 的排序算法（如归并排序和堆排序）具有更好的常数因子，因此在实践中通常更快。

**Java 代码示例（选择最后一个元素作为基准）：**

```java
public class QuickSort {

    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 分区操作，获取基准元素的最终位置
            int partitionIndex = partition(arr, low, high);

            // 递归地对基准左边的子数组进行排序
            quickSort(arr, low, partitionIndex - 1);

            // 递归地对基准右边的子数组进行排序
            quickSort(arr, partitionIndex + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        // 选择最后一个元素作为基准
        int pivot = arr[high];
        // 指向小于基准的元素的最后一个位置
        int i = (low - 1);

        for (int j = low; j < high; j++) {
            // 如果当前元素小于或等于基准
            if (arr[j] <= pivot) {
                // 将 i 加 1，并交换 arr[i] 和 arr[j]
                i++;
                swap(arr, i, j);
            }
        }

        // 将基准元素放到它最终排序后的位置
        swap(arr, i + 1, high);

        // 返回基准元素的索引
        return (i + 1);
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {7, 2, 1, 6, 8, 5, 3, 4};
        System.out.println("排序前数组： " + java.util.Arrays.toString(arr));
        quickSort(arr, 0, arr.length - 1);
        System.out.println("排序后数组： " + java.util.Arrays.toString(arr)); // 输出: [1, 2, 3, 4, 5, 6, 7, 8]
    }
}
```

**总结：**

快速排序是一种高效的排序算法，其平均时间复杂度为 O(n log n)。它通过选择基准元素并进行分区操作，将数组划分为两个子数组，然后递归地对子数组进行排序。虽然在最坏情况下性能可能退化到 O(n^2)，但通过合理的基准选择策略（例如随机选择），可以很大程度上避免这种情况。由于其原地排序的特性和通常较小的常数因子，快速排序在实践中经常被使用。