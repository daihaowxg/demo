# Spring Cache 最佳实践与常见问题

在使用 Spring Cache 时，遵循以下最佳实践可以帮助你构建更可靠、高效的系统。

## 1. 缓存应用场景

### 适合缓存
*   **读多写少**：数据更新频率低，但查询频率高（如：字典数据、配置信息、商品详情）。
*   **计算昂贵**：获取数据需要复杂的计算或耗时的远程调用（如：报表统计、第三方 API 结果）。
*   **一致性要求不高**：允许短时间的数据不一致。

### 不适合缓存
*   **实时性要求极高**：数据变化必须立即反映（如：股市行情、银行余额）。
*   **数据频繁变更**：数据写入频繁，导致缓存频繁失效，缓存命中率过低。
*   **查询条件极其复杂**：很难生成固定的 Cache Key（如：复杂的多字段组合查询、模糊查询）。

## 2. 常见问题及解决方案

### 2.1 缓存穿透 (Cache Penetration)
**问题**：查询一个**根本不存在**的数据，缓存层和存储层都不会命中。通常出于恶意攻击，导致大量请求直接打到数据库。
**解决方案**：
1.  **缓存空对象**：即使数据库返回 null，也将 null 写入缓存（设置较短的过期时间，如 1-5 分钟）。
    *   *本项目示例*：`AdvancedCacheService.getDataAllowNull`
2.  **布隆过滤器 (Bloom Filter)**：在访问缓存前，先通过布隆过滤器判断 key 是否存在，不存在则直接返回。

### 2.2 缓存击穿 (Cache Breakdown)
**问题**：一个**热点 Key**（如爆款商品）突然过期，此时大量并发请求瞬间涌入，直接击穿缓存层打到数据库。
**解决方案**：
1.  **互斥锁 (Mutex)**：只允许一个线程重建缓存，其他线程等待。
    *   *Spring Cache 原生支持*：使用 `sync = true` 属性。
    *   *本项目示例*：`AdvancedCacheService.getHotData`
2.  **永不过期**：物理不过期，逻辑过期（后台异步更新）。

### 2.3 缓存雪崩 (Cache Avalanche)
**问题**：大量的 Key 在**同一时间集中过期**，或者缓存服务器宕机，导致瞬间数据库压力激增。
**解决方案**：
1.  **随机过期时间**：在设置过期时间时，加上一个随机值，将过期时间分散开。
2.  **高可用架构**：对于 Redis，使用 Sentinel 或 Cluster 模式。
3.  **多级缓存**：本地缓存 (Caffeine) + 分布式缓存 (Redis)。
4.  **限流降级**：系统负载过高时，暂时拒绝部分请求或返回降级数据。

## 3. Key 设计最佳实践

好的 Key 命名规范能减少冲突，方便管理。

*   **结构化命名**：使用冒号分隔，如 `app:module:entity:id`。
    *   示例：`shop:product:detail:1001`
*   **包含必要参数**：Key 必须包含影响结果的所有参数。
*   **避免过长**：Redis Key 过长会占用更多内存，且查找效率略低。

**技巧：`#result` vs 参数名**
在 `@CachePut` 场景下，经常需要选择使用参数还是返回值作为 Key：
*   **推荐使用 `#result.id`**：当 ID 是由数据库生成（如自增主键）时。因为入参时 ID 通常为空，只有返回值（方法执行后）才会有 ID。
*   **使用参数名 `#user.id`**：当 ID 由前端传入或方法不返回实体时。

**反例**：
*   使用默认 Key (`SimpleKeyGenerator`)：如果方法参数相同但业务含义不同，可能导致冲突。
*   Key 包含整个对象：如果对象很大，序列化和哈希计算成本高。

## 4. 序列化注意事项

当使用 Redis 等远程缓存时，对象需要序列化。

1.  **Serializable 接口**：Java 对象必须实现 `java.io.Serializable`。
2.  **serialVersionUID**：最好显式定义 `serialVersionUID`，防止类结构变化导致反序列化失败。
3.  **JSON 序列化**：推荐使用 JSON 格式（如 Jackson），可读性好，跨语言。
    *   *本项目配置*：`RedisCacheConfig.java` 中使用了 `Jackson2JsonRedisSerializer`。
4.  **时间类型处理**：注意 `LocalDateTime` 等 Java 8 时间类型的序列化配置。

## 5. 常见坑点

1.  **内部调用不生效**：
    *   *现象*：在同一个类中，方法 A 调用带 `@Cacheable` 的方法 B，缓存不生效。
    *   *原因*：Spring Cache 基于 AOP 代理实现，内部调用绕过了代理对象。
    *   *解决*：将缓存方法抽取到另一个 Service 中，或者通过 AopContext 获取代理对象调用。
2.  **@Transactional 与 @Cacheable 混用**：
    *   如果缓存操作在事务提交前执行（如 `@CachePut`），而事务回滚了，会导致缓存中是脏数据。
    *   *建议*：尽量保持缓存操作在事务外部，或者了解具体的执行顺序。
3.  **多线程环境下的 ThreadLocal**：如果在缓存 Key 生成逻辑中使用了 ThreadLocal，注意多线程切换可能导致的问题。

